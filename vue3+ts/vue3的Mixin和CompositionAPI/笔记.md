# 代码复用
## Mixin
组件与组件间中有相同的逻辑 对相同逻辑抽取
Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能；当组件使用Mixin对象时，所有Mixin对象的选项将被混合进入该组件本身的选项中；
### 基本使用：
```JavaScript
Home.vue
...
export default {
    mixins:[sayHelloMixin]
}
...
sayHello.js
const sayHelloMixin={
    created(){this.sayHello()},
    methods:{sayHello(){console.log('xxx')}}
}

```
data() computed...等等都可以放进Mixin里面
### Mixin的合并规则
> 1. 如果是data函数的返回值对象 返回值对象默认情况下会进行合并；如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据；
> 2. 如何生命周期钩子函数 生命周期的钩子函数会被合并到数组中，都会被调用；
> 3. 值为对象的选项，例如methods、components 和directives，将被合并为同一个对象。比如都有methods选项，并且都定义了方法，那么它们都会生效；但是如果对象的key相同，那么会取组件对象的键值对；

全局混入Mixin
## extends
在开发中extends用的非常少，在Vue2中比较推荐大家使用Mixin，而在Vue3中推荐使用Composition API。

# CompositionAPI

## setup
代替以前的大部分其他选项 比如methods computed watch data 生命周期 等等
里面不能使用this

### 有哪些参数？ 
1. props：父组件传来的属性
2. context：
- attrs：非prop的attribute（比如组件传来的id，class 这些props里面拿不到的）context.attrs.class
- slots：父组件传来的插槽（要拿到的话需要使用render函数形式）
- emit：当组件内部需要发出事件时候会用到emit

### 有什么返回值？
setup返回值return一个对象 可以在模板template里面用 意思就是可以代替data()

### 为什么setup不能使用this
setup里面this并没有指向当前组件实例；并且在setup被调用之前，data、computed、methods等都没有被解析；
所以无法在setup中获取this；

## 响应式Reactive API
data（）里面返回的数据是响应式的 因为放到了reactive函数里面处理了，但是setup没有，所以想在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数<br/>
[代码链接](./CompositionAPI/src/响应式reactive.vue)

## Ref API
reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型：传入一个基本数据类型（String、Number、Boolean）会报一个警告；所以需要ref API
```javascript
const ab = ref("hello world")
```
>注意：1、在temelate模板里面使用的时候 无需通过ref.value 因为vue会帮助自动解包:{{ab}}
2、在setup里面使用的时候，它依然是一个ref引用， 所以需要使用ref.value的方式: ab.value

