# 代码复用
## Mixin
组件与组件间中有相同的逻辑 对相同逻辑抽取
Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能；当组件使用Mixin对象时，所有Mixin对象的选项将被混合进入该组件本身的选项中；
### 基本使用：
```JavaScript
Home.vue
...
export default {
    mixins:[sayHelloMixin]
}
...
sayHello.js
const sayHelloMixin={
    created(){this.sayHello()},
    methods:{sayHello(){console.log('xxx')}}
}

```
data() computed...等等都可以放进Mixin里面
### Mixin的合并规则
> 1. 如果是data函数的返回值对象 返回值对象默认情况下会进行合并；如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据；
> 2. 如何生命周期钩子函数 生命周期的钩子函数会被合并到数组中，都会被调用；
> 3. 值为对象的选项，例如methods、components 和directives，将被合并为同一个对象。比如都有methods选项，并且都定义了方法，那么它们都会生效；但是如果对象的key相同，那么会取组件对象的键值对；

全局混入Mixin
## extends
在开发中extends用的非常少，在Vue2中比较推荐大家使用Mixin，而在Vue3中推荐使用Composition API。

# CompositionAPI

## setup
代替以前的大部分其他选项 比如methods computed watch data 生命周期 等等
里面不能使用this

### 有哪些参数？ 
1. props：父组件传来的属性
2. context：
- attrs：非prop的attribute（比如组件传来的id，class 这些props里面拿不到的）context.attrs.class
- slots：父组件传来的插槽（要拿到的话需要使用render函数形式）
- emit：当组件内部需要发出事件时候会用到emit

### 有什么返回值？
setup返回值return一个对象 可以在模板template里面用 意思就是可以代替data()

### 为什么setup不能使用this
setup里面this并没有指向当前组件实例；并且在setup被调用之前，data、computed、methods等都没有被解析；
所以无法在setup中获取this；

## 响应式Reactive API
>必须传入的是一个对象或者数组类型 如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改reactive返回的state对象，数据都不再是响应式的了 这时候就需要用到toRefs()包裹定义的reactive（xxx）

data（）里面返回的数据是响应式的 因为放到了reactive函数里面处理了，但是setup没有，所以想在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数 <br/>
[代码链接](./CompositionAPI/src/响应式reactive.vue)

## Ref API
reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型：传入一个基本数据类型 **（String、Number、Boolean）** 会报一个警告；所以需要ref API
```javascript
const ab = ref("hello world")
```
>注意：1、在temelate模板里面使用的时候 无需通过ref.value 因为vue会帮助自动解包，**只能是浅层解包**:{{ab}}
2、在setup里面使用的时候，它依然是一个ref引用， 所以需要使用ref.value的方式: ab.value

## readonly
>通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下,在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了；
readonly会返回原生对象的只读代理（也就是它依然是一个Proxy，这是一个proxy的set方法被劫持，并且不能对其进行修改）；
readonly包裹起来
<u>**其实本质上就是readonly返回的对象的setter方法被劫持了而已**</u>

### readonly方法会传入三个类型的参数
1. 类型一：普通对象；
2. 类型二：reactive返回的对象；
3. 类型三：ref的对象；
### 规则
readonly<u>返回的对象</u>都是不允许修改的；但是经过readonly处理的<u>原来的对象</u>是允许被修改的；
比如const info = readonly(obj)，info对象是 不允许被修改的；
当obj被修改时，readonly返回的info对象也会被修改；
但是我们不能去修改readonly返回的对象info；
## Reactive判断的API
- isProxy 检查对象是否由reactive或readonly创建的proxy
- isReactive
检查对象是否是由reactive创建的响应式代理：
如果该代理是readonly 建的，但包裹了由reactive 创建的另一个代理，它也会返回true；
- isReadonly
 检查对象是否是由readonly 创建的只读代理。
- toRaw
 返回reactive 或readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。
- shallowReactive
 创建一个响应式代理，它跟踪其自身property 的响应性，但不执行嵌套对象的深层响应式转换(深层还是原生对象)。
- shallowReadonly
 创建一个proxy，使其自身的property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）。
## toRefs
>可以将reactive返回的对象中的属性都转成ref；

如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改reactive
返回的state对象，数据都不再是响应式的：
```javascript
const state = reactive({
    a:'why',b:16
})
const {a,b}=state  此时state里面的a、b不再是响应式的了
```
**要想解构出来的属性是响应式---用到toRefs()**
```javascript
const {a,b}=toRefs(state) 结构出来的a和b本身都是ref的；
```
## toRef
>如果我们只希望转换一个reactive对象中的属性为ref, 那么可以使用toRef的方法

```javascript
const state = reactive({
    a:'why',b:16
})
const a=toRef(state,'a')  此时仅结构出来a 变成响应式
```
## customRef
创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制：
它需要一个工厂函数，该函数接受track 和trigger 函数作为参数；track()决定什么时候搜集依赖 tigger()表示触发更新
并且应该返回一个带有get 和set 的对象；

使用一个的案例：
[对双向绑定的属性进行debounce(节流)的操作](./CompositionAPI/src/customRef)
## computed
 写在setup()里面
 computed本身返回的是一个ref对象
```javascript
setup(){
    //用法一：传一个getter
    const fullname = computed(()=>firstName.value+''+lastName.value)
    //用法二：传一个对象，对象包含getter/setter
    cnst fullname = computed({get:()=>firstname.value+''+lastName.value,
    set(newValue){
        firstName.value=xxx
    }
    })
}
```